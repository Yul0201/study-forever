## 재귀함수와 반복문 비교

|구분|반복문|재귀함수|
|--:|--:|--:|
|정의|명령을 반복적으로 수행|함수를 다시 호출하여 반복작업 수행|
|스택메모리|스택 메모리를 사용하지 않음|함수 호출 시 함수의 매개변구,지역변수, 리턴값, 함수 종료 후 돌아가는 위치가 스택메모리에 저장|
|무한반복|무한루프는 CPU 사이클을 반복적으로 사용|무한 재귀는 스택 오버 플로우 발생|
|속도|빠른 실행|느린 실행|  


> **Stack Overflow**  
재귀함수 사용 시, 함수를 `반복적`으로 호출하므로, 스택메모리에 콜 스택이 쌓이게 된다. 이때 함수를 호출하는 횟수가 많아진다면 스택메모리를 초과하여 stack overflow가 발생하는 것이다. (일반적인 반복문 사용 시, 지역 변수들이 호출될 때 한번만 할당되기 때문에 이러한 일이 발생하지 않는다.)  
  

## 재귀함수를 사용하는 이유

- 재귀함수는 반복문으로 구현가능하고 그 반대도 가능함

    - 변수의 수를 줄일 수 있다 -> 메서드를 재귀적으로 호출하면서 변경된 상태를 전달하면서 변수의 수를 줄일 수 있다

    - 코드가 간결해진다 (반복문에 비해)



- 재귀를 활용한 함수  



``` c#

int 
factorial (int n)

{

    if(n===1)
 {

        return
1;

    }

    return
n 
* factorial(n-1);

}

```  

![](2024-09-30-12-28-16.png)

> 함수 호출 시마다 콜스택에는 함수의 매개변수, 지역변수, 반환 주소값 등을 모두 저장하는데 factorial(5)를 호출하면 반환 타입에서 5*factorial(5-1)이 수행되면서 factorial(4)가 호출되고 반환을 기다린다. 위의 방식으로 factorial(1)까지 콜스택에 쌓이고 인자가 1이 되면서 콜스택이 하나씩 수행되면 사라질 것이다  

->  __*오버헤드 발생*__

  



- Stack Overflow 발생하는 함수  

``` c#

int 
factorial (int n)

{

    return
n 
* factorial(n-1);

}

```



- 재귀함수의 단점 해결 방법_꼬리함수  

   - 반환 부분에 연산이 없어야 하며 반환부에 연산이 없으면 컴파일 시 자체적으로 재귀함수를 해석해서 반복문으로 변경하고 실행

``` c#

// Basic Recursion

int 
factorial(int n,
int total) {

    if (n
=== 
1) { 

        return
1; 

    } 

    return
n 
* factorial(n-1);

}



// Tail Recursion

int 
factorial(int n, total) {

    if (n
=== 
1) { 

        return
1; 

    } 

    return
factorial(n
- 
1, n
* 
total);

}

```



- 참고문서

*__https://catsbi.oopy.io/dbcc8c79-4600-4655-b2e2-b76eb7309e60__*

- 참고문헌  
__*https://yeonjewon.tistory.com/80*__